Dia 6
Elección del problema:
Se ha elegido este problema porque involucra recorrer un laberinto de manera eficiente, marcando las posiciones visitadas y evitando recorrer varias veces las mismas áreas. Es útil para problemas como la navegación en mapas o la búsqueda de caminos.

Técnicas y estructuras de datos empleadas:
Búsqueda en Anchura (BFS): Para recorrer el laberinto de manera ordenada, asegurando que encontramos el camino más corto.
Tabla Hash: Para almacenar las posiciones visitadas y evitar recorrer las mismas celdas múltiples veces, mejorando la eficiencia.

Enfoque de la solución:
Se lee el laberinto desde un archivo de entrada.
Se localiza la posición inicial del recorrido.
Usando BFS, se exploran las posiciones adyacentes y se marcan las celdas visitadas en el mapa.
Se almacena el estado de las celdas visitadas en una tabla hash para evitar retrocesos.
Al final, se muestra el camino recorrido y el número total de movimientos realizados.

Codigo de ejecuccion:
g++ -o guardtest Day6.cpp 
